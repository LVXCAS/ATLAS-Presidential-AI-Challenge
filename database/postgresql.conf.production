# PostgreSQL Configuration for High-Frequency Trading
# Optimized for real-time performance with Hive Trade v0.2

# CONNECTIONS AND AUTHENTICATION
listen_addresses = '*'
port = 5432
max_connections = 200
superuser_reserved_connections = 3

# MEMORY SETTINGS
shared_buffers = 512MB                    # 25% of total RAM for dedicated DB server
temp_buffers = 8MB
work_mem = 16MB                          # Increased for complex queries
maintenance_work_mem = 256MB             # For index creation and maintenance
effective_cache_size = 2GB               # Total system cache (75% of RAM)
huge_pages = try

# QUERY PLANNER SETTINGS
random_page_cost = 1.1                   # Optimized for SSD storage
seq_page_cost = 1.0
cpu_tuple_cost = 0.01
cpu_index_tuple_cost = 0.005
cpu_operator_cost = 0.0025
effective_io_concurrency = 200          # For SSD, set to CPU core count * 50

# PARALLEL QUERY SETTINGS
max_worker_processes = 8
max_parallel_workers = 8
max_parallel_workers_per_gather = 4
max_parallel_maintenance_workers = 4
parallel_tuple_cost = 0.01
parallel_setup_cost = 1000.0

# WRITE AHEAD LOGGING (WAL)
wal_level = replica
wal_compression = on
wal_buffers = 16MB
checkpoint_completion_target = 0.9
checkpoint_timeout = 15min
max_wal_size = 2GB
min_wal_size = 512MB
wal_keep_segments = 32

# REPLICATION (for future use)
max_wal_senders = 3
hot_standby = on
hot_standby_feedback = on

# BACKGROUND WRITER
bgwriter_delay = 200ms
bgwriter_lru_maxpages = 100
bgwriter_lru_multiplier = 2.0
bgwriter_flush_after = 512kB

# ASYNCHRONOUS BEHAVIOR
effective_io_concurrency = 200
max_worker_processes = 8
backend_flush_after = 256kB

# COST-BASED VACUUM DELAY (disabled for real-time performance)
vacuum_cost_delay = 0
vacuum_cost_page_hit = 1
vacuum_cost_page_miss = 10
vacuum_cost_page_dirty = 20
vacuum_cost_limit = 2000

# AUTOVACUUM PARAMETERS (aggressive for high-write workloads)
autovacuum = on
autovacuum_max_workers = 4
autovacuum_naptime = 15s
autovacuum_vacuum_threshold = 25
autovacuum_vacuum_scale_factor = 0.1
autovacuum_analyze_threshold = 10
autovacuum_analyze_scale_factor = 0.05
autovacuum_freeze_max_age = 200000000
autovacuum_multixact_freeze_max_age = 400000000
autovacuum_vacuum_cost_delay = 10ms
autovacuum_vacuum_cost_limit = 1000

# CLIENT CONNECTION DEFAULTS
statement_timeout = 30s                 # Prevent long-running queries
lock_timeout = 10s                      # Fast failure on locks
idle_in_transaction_session_timeout = 60s

# LOGGING
log_destination = 'stderr,csvlog'
logging_collector = on
log_directory = 'log'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
log_file_mode = 0600
log_rotation_age = 1d
log_rotation_size = 100MB

# WHAT TO LOG
log_min_messages = warning
log_min_error_statement = error
log_min_duration_statement = 100ms      # Log queries > 100ms
log_checkpoints = on
log_connections = on
log_disconnections = on
log_lock_waits = on
log_temp_files = 10MB
log_autovacuum_min_duration = 0
log_error_verbosity = default
log_statement = 'mod'                   # Log DDL/DML statements
log_replication_commands = off

# RUNTIME STATISTICS
track_activities = on
track_counts = on
track_io_timing = on
track_functions = all
stats_temp_directory = 'pg_stat_tmp'

# STATEMENT STATISTICS (for query analysis)
shared_preload_libraries = 'pg_stat_statements'
pg_stat_statements.max = 10000
pg_stat_statements.track = all
pg_stat_statements.track_utility = on
pg_stat_statements.save = on

# CLIENT CONNECTION DEFAULTS
default_text_search_config = 'pg_catalog.english'
timezone = 'UTC'
lc_messages = 'C'
lc_monetary = 'C'
lc_numeric = 'C'
lc_time = 'C'
default_transaction_isolation = 'read committed'

# LOCK MANAGEMENT (optimized for high concurrency)
deadlock_timeout = 1s
max_locks_per_transaction = 256
max_pred_locks_per_transaction = 256

# PERFORMANCE OPTIMIZATIONS FOR TRADING
# Enable JIT compilation for complex queries (PostgreSQL 11+)
jit = on
jit_above_cost = 100000
jit_inline_above_cost = 500000
jit_optimize_above_cost = 500000

# Constraint exclusion for partitioned tables
constraint_exclusion = partition

# Synchronous commit (balance between performance and durability)
synchronous_commit = on                  # Can be set to 'off' for maximum performance if data loss is acceptable
fsync = on                              # Can be disabled for maximum performance in development
full_page_writes = on                   # Can be disabled for SSD in some cases

# Additional optimizations
tcp_keepalives_idle = 600
tcp_keepalives_interval = 30
tcp_keepalives_count = 3

# Locale settings
datestyle = 'iso, mdy'
intervalstyle = 'postgres'

# Memory overcommit (Linux specific)
# vm.overcommit_memory = 2
# vm.overcommit_ratio = 50

# These settings should be added to /etc/sysctl.conf on Linux:
# kernel.shmmax = 1073741824
# kernel.shmall = 2097152
# kernel.sem = 250 32000 100 128
# fs.file-max = 65536
# net.ipv4.ip_local_port_range = 9000 65500
# net.core.rmem_default = 262144
# net.core.rmem_max = 16777216
# net.core.wmem_default = 262144
# net.core.wmem_max = 16777216