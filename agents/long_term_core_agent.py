\"\"\"\nLong-Term Core Agent for the LangGraph Adaptive Multi-Strategy AI Trading System.\n\nThis agent implements long-term fundamental investing strategies that focus on identifying\nhigh-quality companies with strong fundamentals, sustainable competitive advantages, and\nfavorable long-term growth prospects. It incorporates macro overlay analysis, ESG factors,\nand options-based hedging strategies for risk management.\n\nKey Features:\n- Fundamental analysis screening for quality companies\n- Macro overlay and regime awareness\n- Options hedging for long-term positions\n- ESG and sustainability filters\n- Dynamic position sizing based on conviction\n\"\"\"\n\nimport asyncio\nimport logging\nfrom datetime import datetime, timedelta\nfrom enum import Enum\nfrom typing import Dict, List, Optional, Tuple\n\nimport numpy as np\nimport pandas as pd\nfrom pydantic import BaseModel, Field\n\nfrom config.settings import LONG_TERM_CORE_SETTINGS\nfrom data.market_data import get_historical_data, get_real_time_data\nfrom data.economic_data import get_economic_indicators, get_macro_overlay_signals\nfrom strategies.technical_indicators import TechnicalIndicators\nfrom .news_sentiment_agent import NewsSentimentAgent\nfrom .economic_data_agent import EconomicDataAgent\nfrom .options_volatility_agent import OptionsVolatilityAgent\n\nlogger = logging.getLogger(__name__)\n\nclass LongTermSignalType(str, Enum):\n    \"\"\"Types of long-term core signals\"\"\"\n    QUALITY_GROWTH = \"quality_growth\"\n    VALUE_OPPORTUNITY = \"value_opportunity\"\n    DIVIDEND_ARBITRAGE = \"dividend_arbitrage\"\n    MACRO_OVERLAY = \"macro_overlay\"\n    ESG_LEADERSHIP = \"esg_leadership\"\n\nclass LongTermPositionData(BaseModel):\n    \"\"\"Data model for long-term position information\"\"\"\n    symbol: str\n    price: float\n    quantity: float\n    timestamp: datetime\n    conviction_score: float = Field(ge=0.0, le=1.0)\n    risk_score: float = Field(ge=0.0, le=1.0)\n    target_price: float\n    time_horizon: int  # Days\n    signal_type: LongTermSignalType\n    explanation: str\n    fundamental_factors: List[str]\n    macro_factors: List[str]\n    esg_factors: List[str]\n    hedging_strategy: Optional[str]\n\nclass LongTermMetrics(BaseModel):\n    \"\"\"Metrics for evaluating long-term core opportunities\"\"\"\n    symbol: str\n    quality_score: float = Field(ge=0.0, le=1.0)  # Higher = better quality\n    value_score: float = Field(ge=0.0, le=1.0)  # Higher = more undervalued\n    growth_score: float = Field(ge=0.0, le=1.0)  # Higher = better growth prospects\n    dividend_score: float = Field(ge=0.0, le=1.0)  # Higher = better dividend profile\n    macro_score: float = Field(ge=0.0, le=1.0)  # Higher = favorable macro environment\n    esg_score: float = Field(ge=0.0, le=1.0)  # Higher = better ESG profile\n    overall_score: float = Field(ge=0.0, le=1.0)  # Composite score\n\nclass LongTermCoreAgent:\n    \"\"\"LangGraph agent for long-term fundamental investing strategies\"\"\"\n    \n    def __init__(self):\n        self.name = \"long_term_core_agent\"\n        self.settings = LONG_TERM_CORE_SETTINGS\n        self.technical_indicators = TechnicalIndicators()\n        self.news_sentiment_agent = NewsSentimentAgent()\n        self.economic_data_agent = EconomicDataAgent()\n        self.options_volatility_agent = OptionsVolatilityAgent()\n        \n    async def analyze_long_term_opportunities(self, symbols: List[str]) -> List[LongTermMetrics]:\n        \"\"\"Analyze multiple symbols for long-term core opportunities\"\"\"\n        long_term_metrics = []\n        \n        for symbol in symbols:\n            try:\n                metrics = await self._analyze_single_symbol(symbol)\n                long_term_metrics.append(metrics)\n            except Exception as e:\n                logger.error(f\"Error analyzing {symbol} for long-term opportunities: {e}\")\n                continue\n                \n        # Sort by overall score (highest first)\n        long_term_metrics.sort(key=lambda x: x.overall_score, reverse=True)\n        return long_term_metrics\n        \n    async def _analyze_single_symbol(self, symbol: str) -> LongTermMetrics:\n        \"\"\"Analyze a single symbol for long-term core opportunity\"\"\"\n        # Get historical and real-time data\n        hist_data = await get_historical_data(symbol, days=365)  # 1 year for long-term analysis\n        real_time_data = await get_real_time_data(symbol)\n        \n        # Calculate various scores\n        quality_score = await self._calculate_quality_score(symbol, hist_data, real_time_data)\n        value_score = await self._calculate_value_score(symbol, hist_data, real_time_data)\n        growth_score = await self._calculate_growth_score(symbol, hist_data, real_time_data)\n        dividend_score = await self._calculate_dividend_score(symbol, real_time_data)\n        macro_score = await self._calculate_macro_score(symbol)\n        esg_score = await self._calculate_esg_score(symbol)\n        \n        # Calculate overall score with weighted components\n        overall_score = self._calculate_overall_score(\n            quality_score, value_score, growth_score, \n            dividend_score, macro_score, esg_score\n        )\n        \n        return LongTermMetrics(\n            symbol=symbol,\n            quality_score=quality_score,\n            value_score=value_score,\n            growth_score=growth_score,\n            dividend_score=dividend_score,\n            macro_score=macro_score,\n            esg_score=esg_score,\n            overall_score=overall_score\n        )\n        \n    async def _calculate_quality_score(self, symbol: str, hist_data: pd.DataFrame, real_time_data: Dict) -> float:\n        \"\"\"Calculate quality-based long-term score\"\"\"\n        try:\n            # Quality metrics typically include:\n            # - Return on Equity (ROE)\n            # - Return on Assets (ROA)\n            # - Debt-to-Equity ratio\n            # - Profit margins\n            # - Revenue stability\n            \n            roe = real_time_data.get('roe', 0.0)\n            roa = real_time_data.get('roa', 0.0)\n            debt_to_equity = real_time_data.get('debt_to_equity', 1.0)\n            profit_margin = real_time_data.get('profit_margin', 0.0)\n            \n            # Calculate quality components\n            # Higher ROE/ROA is better (capped at reasonable levels)\n            roe_score = min(1.0, max(0.0, roe / 0.20))  # Normalize to 20% threshold\n            roa_score = min(1.0, max(0.0, roa / 0.10))  # Normalize to 10% threshold\n            \n            # Lower debt-to-equity is better\n            debt_score = max(0.0, min(1.0, (1.0 - debt_to_equity) if debt_to_equity < 1.0 else 0.0))\n            \n            # Higher profit margin is better\n            margin_score = min(1.0, max(0.0, profit_margin / 0.15))  # Normalize to 15% threshold\n            \n            # Revenue stability from historical data\n            if len(hist_data) > 4:\n                quarterly_revenue = hist_data['revenue'].resample('Q').last().dropna()\n                if len(quarterly_revenue) > 4:\n                    revenue_growth_rates = quarterly_revenue.pct_change().dropna()\n                    revenue_stability = 1.0 - revenue_growth_rates.std()  # Lower std = more stable\n                    stability_score = max(0.0, min(1.0, revenue_stability))\n                else:\n                    stability_score = 0.5\n            else:\n                stability_score = 0.5\n            \n            # Weighted average of quality metrics\n            quality_score = (\n                roe_score * 0.3 + \n                roa_score * 0.2 + \n                debt_score * 0.2 + \n                margin_score * 0.2 + \n                stability_score * 0.1\n            )\n            \n            return min(1.0, quality_score)\n        except Exception as e:\n            logger.warning(f\"Error calculating quality score for {symbol}: {e}\")\n            return 0.0\n            \n    async def _calculate_value_score(self, symbol: str, hist_data: pd.DataFrame, real_time_data: Dict) -> float:\n        \"\"\"Calculate value-based long-term score\"\"\"\n        try:\n            # Value metrics typically include:\n            # - Price-to-Earnings ratio\n            # - Price-to-Book ratio\n            # - Price-to-Sales ratio\n            # - Enterprise Value ratios\n            \n            pe_ratio = real_time_data.get('pe_ratio', 25.0)  # Default to market average\n            pb_ratio = real_time_data.get('pb_ratio', 3.0)   # Default to market average\n            ps_ratio = real_time_data.get('ps_ratio', 5.0)   # Default to market average\n            \n            # Calculate percentile ranks vs historical data (for relative value)\n            if len(hist_data) > 30:\n                hist_pe = hist_data['pe_ratio'].dropna()\n                hist_pb = hist_data['pb_ratio'].dropna()\n                hist_ps = hist_data['ps_ratio'].dropna()\n                \n                if len(hist_pe) > 10:\n                    pe_percentile = np.percentile(hist_pe, 25)  # 25th percentile as value threshold\n                    pe_score = max(0.0, min(1.0, (pe_percentile - pe_ratio) / pe_percentile))\n                else:\n                    pe_score = max(0.0, min(1.0, (25.0 - pe_ratio) / 25.0))  # Use defaults\n                    \n                if len(hist_pb) > 10:\n                    pb_percentile = np.percentile(hist_pb, 25)\n                    pb_score = max(0.0, min(1.0, (pb_percentile - pb_ratio) / pb_percentile))\n                else:\n                    pb_score = max(0.0, min(1.0, (3.0 - pb_ratio) / 3.0))\n                    \n                if len(hist_ps) > 10:\n                    ps_percentile = np.percentile(hist_ps, 25)\n                    ps_score = max(0.0, min(1.0, (ps_percentile - ps_ratio) / ps_percentile))\n                else:\n                    ps_score = max(0.0, min(1.0, (5.0 - ps_ratio) / 5.0))\n            else:\n                # Use absolute value thresholds if no historical data\n                pe_score = max(0.0, min(1.0, (25.0 - pe_ratio) / 25.0))\n                pb_score = max(0.0, min(1.0, (3.0 - pb_ratio) / 3.0))\n                ps_score = max(0.0, min(1.0, (5.0 - ps_ratio) / 5.0))\n            \n            # Weighted average\n            value_score = (pe_score * 0.4 + pb_score * 0.3 + ps_score * 0.3)\n            return min(1.0, value_score)\n        except Exception as e:\n            logger.warning(f\"Error calculating value score for {symbol}: {e}\")\n            return 0.0\n            \n    async def _calculate_growth_score(self, symbol: str, hist_data: pd.DataFrame, real_time_data: Dict) -> float:\n        \"\"\"Calculate growth-based long-term score\"\"\"\n        try:\n            # Growth metrics typically include:\n            # - Earnings growth rate\n            # - Revenue growth rate\n            # - Book value growth\n            # - Dividend growth\n            \n            earnings_growth = real_time_data.get('earnings_growth', 0.0)\n            revenue_growth = real_time_data.get('revenue_growth', 0.0)\n            \n            # Calculate historical growth rates if available\n            if len(hist_data) > 4:\n                # Quarterly earnings growth\n                quarterly_earnings = hist_data['earnings'].resample('Q').last().dropna()\n                if len(quarterly_earnings) > 4:\n                    earnings_growth_hist = quarterly_earnings.pct_change().mean() * 4  # Annualized\n                else:\n                    earnings_growth_hist = 0.0\n                    \n                # Quarterly revenue growth\n                quarterly_revenue = hist_data['revenue'].resample('Q').last().dropna()\n                if len(quarterly_revenue) > 4:\n                    revenue_growth_hist = quarterly_revenue.pct_change().mean() * 4  # Annualized\n                else:\n                    revenue_growth_hist = 0.0\n            else:\n                earnings_growth_hist = 0.0\n                revenue_growth_hist = 0.0\n            \n            # Combine current and historical growth metrics\n            combined_earnings_growth = (earnings_growth + earnings_growth_hist) / 2\n            combined_revenue_growth = (revenue_growth + revenue_growth_hist) / 2\n            \n            # Score growth rates (15% annual growth = max score)\n            earnings_growth_score = min(1.0, max(0.0, combined_earnings_growth / 0.15))\n            revenue_growth_score = min(1.0, max(0.0, combined_revenue_growth / 0.15))\n            \n            # Weighted average\n            growth_score = (earnings_growth_score * 0.6 + revenue_growth_score * 0.4)\n            return min(1.0, growth_score)\n        except Exception as e:\n            logger.warning(f\"Error calculating growth score for {symbol}: {e}\")\n            return 0.0\n            \n    async def _calculate_dividend_score(self, symbol: str, real_time_data: Dict) -> float:\n        \"\"\"Calculate dividend-based long-term score\"\"\"\n        try:\n            # Dividend metrics typically include:\n            # - Dividend yield\n            # - Dividend payout ratio\n            # - Dividend growth history\n            # - Dividend safety\n            \n            dividend_yield = real_time_data.get('dividend_yield', 0.0)\n            payout_ratio = real_time_data.get('payout_ratio', 1.0)\n            \n            # Score dividend yield (5% yield = max score)\n            yield_score = min(1.0, max(0.0, dividend_yield / 0.05))\n            \n            # Score payout ratio (lower is better, but not too low)\n            # Optimal range: 30-60%\n            if 0.3 <= payout_ratio <= 0.6:\n                payout_score = 1.0\n            elif payout_ratio < 0.3:\n                payout_score = max(0.0, payout_ratio / 0.3)  # Lower scores for very low payout\n            else:  # payout_ratio > 0.6\n                payout_score = max(0.0, (1.0 - payout_ratio) / 0.4)  # Decreasing score for high payout\n            \n            # Weighted average\n            dividend_score = (yield_score * 0.6 + payout_score * 0.4)\n            return min(1.0, dividend_score)\n        except Exception as e:\n            logger.warning(f\"Error calculating dividend score for {symbol}: {e}\")\n            return 0.0\n            \n    async def _calculate_macro_score(self, symbol: str) -> float:\n        \"\"\"Calculate macro overlay score\"\"\"\n        try:\n            # Get macro overlay signals\n            macro_signals = await get_macro_overlay_signals()\n            \n            # In a real implementation, this would be symbol-specific based on:\n            # - Sector/industry exposure\n            # - Geographic exposure\n            # - Sensitivity to interest rates, inflation, etc.\n            \n            # For now, we'll use a simplified approach\n            overall_macro_score = macro_signals.get('overall_sentiment', 0.0)\n            # Convert from -1/+1 scale to 0/1 scale\n            normalized_macro_score = (overall_macro_score + 1) / 2\n            \n            return normalized_macro_score\n        except Exception as e:\n            logger.warning(f\"Error calculating macro score for {symbol}: {e}\")\n            return 0.5  # Neutral score\n            \n    async def _calculate_esg_score(self, symbol: str) -> float:\n        \"\"\"Calculate ESG (Environmental, Social, Governance) score\"\"\"\n        try:\n            # In a real implementation, this would fetch actual ESG data\n            # For now, we'll simulate with some basic logic\n            \n            # Simulate ESG score with a beta distribution skewed toward moderate scores\n            # ESG scores are typically not extremely high or low\n            esg_score = np.random.beta(3, 3)  # Mean around 0.5, but with variance\n            return esg_score\n        except Exception as e:\n            logger.warning(f\"Error calculating ESG score for {symbol}: {e}\")\n            return 0.5  # Neutral score\n            \n    def _calculate_overall_score(self, quality_score: float, value_score: float, \n                                growth_score: float, dividend_score: float,\n                                macro_score: float, esg_score: float) -> float:\n        \"\"\"Calculate overall long-term core score\"\"\"\n        # Weight components based on long-term investing philosophy\n        weighted_quality = quality_score * 0.30\n        weighted_value = value_score * 0.25\n        weighted_growth = growth_score * 0.20\n        weighted_dividend = dividend_score * 0.10\n        weighted_macro = macro_score * 0.10\n        weighted_esg = esg_score * 0.05\n        \n        # Combine all factors\n        overall_score = (\n            weighted_quality + \n            weighted_value + \n            weighted_growth + \n            weighted_dividend + \n            weighted_macro + \n            weighted_esg\n        )\n        \n        return min(1.0, max(0.0, overall_score))\n        \n    async def generate_long_term_signals(self, symbols: List[str], max_positions: int = 5) -> List[LongTermPositionData]:\n        \"\"\"Generate long-term core signals for top opportunities\"\"\"\n        # Analyze all symbols\n        long_term_metrics = await self.analyze_long_term_opportunities(symbols)\n        \n        # Filter for qualified opportunities (score > threshold)\n        qualified_opportunities = [\n            metric for metric in long_term_metrics \n            if metric.overall_score > self.settings.min_long_term_score_threshold\n        ]\n        \n        # Sort by overall score and take top N\n        qualified_opportunities.sort(key=lambda x: x.overall_score, reverse=True)\n        top_opportunities = qualified_opportunities[:max_positions]\n        \n        # Generate signals for top opportunities\n        signals = []\n        for opportunity in top_opportunities:\n            try:\n                signal = await self._generate_signal_for_opportunity(opportunity)\n                if signal:\n                    signals.append(signal)\n            except Exception as e:\n                logger.error(f\"Error generating signal for {opportunity.symbol}: {e}\")\n                continue\n                \n        return signals\n        \n    async def _generate_signal_for_opportunity(self, opportunity: LongTermMetrics) -> Optional[LongTermPositionData]:\n        \"\"\"Generate detailed long-term position signal for an opportunity\"\"\"\n        try:\n            # Get current price\n            real_time_data = await get_real_time_data(opportunity.symbol)\n            current_price = real_time_data.get('price', 0.0)\n            \n            if current_price <= 0:\n                return None\n                \n            # Determine signal type based on highest contributing factor\n            score_components = {\n                'quality': opportunity.quality_score,\n                'value': opportunity.value_score,\n                'growth': opportunity.growth_score,\n                'dividend': opportunity.dividend_score,\n                'macro': opportunity.macro_score,\n                'esg': opportunity.esg_score\n            }\n            \n            signal_type = LongTermSignalType(max(score_components, key=score_components.get))\n            \n            # Create explanation\n            explanation = self._create_explanation(opportunity, signal_type)\n            \n            # Determine fundamental, macro, and ESG factors\n            fundamental_factors = self._extract_fundamental_factors(opportunity)\n            macro_factors = self._extract_macro_factors(opportunity)\n            esg_factors = self._extract_esg_factors(opportunity)\n            \n            # Calculate conviction score (based on overall score)\n            conviction_score = opportunity.overall_score\n            \n            # Calculate risk score (inverse of quality score - higher quality = lower risk)\n            risk_score = 1.0 - opportunity.quality_score\n            \n            # Calculate target price (20% upside for quality companies as default)\n            target_price = current_price * (1 + 0.20)\n            \n            # Time horizon in days (long-term = 180+ days)\n            time_horizon = 365  # 1 year default\n            \n            # Determine hedging strategy\n            hedging_strategy = await self._determine_hedging_strategy(opportunity)\n            \n            return LongTermPositionData(\n                symbol=opportunity.symbol,\n                price=current_price,\n                quantity=0.0,  # Quantity will be determined by portfolio allocator\n                timestamp=datetime.now(),\n                conviction_score=conviction_score,\n                risk_score=risk_score,\n                target_price=target_price,\n                time_horizon=time_horizon,\n                signal_type=signal_type,\n                explanation=explanation,\n                fundamental_factors=fundamental_factors,\n                macro_factors=macro_factors,\n                esg_factors=esg_factors,\n                hedging_strategy=hedging_strategy\n            )\n        except Exception as e:\n            logger.error(f\"Error generating signal for {opportunity.symbol}: {e}\")\n            return None\n            \n    def _create_explanation(self, opportunity: LongTermMetrics, signal_type: LongTermSignalType) -> str:\n        \"\"\"Create human-readable explanation for the long-term signal\"\"\"\n        explanations = {\n            LongTermSignalType.QUALITY_GROWTH: (\n                f\"{opportunity.symbol} identified as high-quality growth company with quality score {opportunity.quality_score:.2f} \" +\n                f\"and growth score {opportunity.growth_score:.2f}. Strong fundamentals and growth prospects.\"\n            ),\n            LongTermSignalType.VALUE_OPPORTUNITY: (\n                f\"{opportunity.symbol} presents value opportunity with value score {opportunity.value_score:.2f}. \" +\n                f\"Attractive valuations relative to peers and historical norms.\"\n            ),\n            LongTermSignalType.DIVIDEND_ARBITRAGE: (\n                f\"{opportunity.symbol} offers attractive dividend profile with score {opportunity.dividend_score:.2f}. \" +\n                f\"Strong dividend yield and sustainable payout ratio.\"\n            ),\n            LongTermSignalType.MACRO_OVERLAY: (\n                f\"{opportunity.symbol} benefits from favorable macro conditions with score {opportunity.macro_score:.2f}. \" +\n                f\"Sector and geographic exposure aligned with positive macro trends.\"\n            ),\n            LongTermSignalType.ESG_LEADERSHIP: (\n                f\"{opportunity.symbol} demonstrates ESG leadership with score {opportunity.esg_score:.2f}. \" +\n                f\"Strong environmental, social, and governance practices.\"\n            )\n        }\n        return explanations.get(signal_type, f\"Long-term signal generated for {opportunity.symbol} with overall score {opportunity.overall_score:.2f}\")\n        \n    def _extract_fundamental_factors(self, opportunity: LongTermMetrics) -> List[str]:\n        \"\"\"Extract key fundamental factors\"\"\"\n        factors = []\n        if opportunity.quality_score > 0.7:\n            factors.append(\"High-quality business\")\n        elif opportunity.quality_score > 0.5:\n            factors.append(\"Solid business quality\")\n            \n        if opportunity.value_score > 0.7:\n            factors.append(\"Attractive valuations\")\n        elif opportunity.value_score > 0.5:\n            factors.append(\"Reasonable valuations\")\n            \n        if opportunity.growth_score > 0.7:\n            factors.append(\"Strong growth prospects\")\n        elif opportunity.growth_score > 0.5:\n            factors.append(\"Steady growth\")\n            \n        return factors\n        \n    def _extract_macro_factors(self, opportunity: LongTermMetrics) -> List[str]:\n        \"\"\"Extract key macro factors\"\"\"\n        factors = []\n        if opportunity.macro_score > 0.7:\n            factors.append(\"Favorable macro environment\")\n        elif opportunity.macro_score > 0.5:\n            factors.append(\"Neutral macro environment\")\n        else:\n            factors.append(\"Challenging macro environment\")\n            \n        return factors\n        \n    def _extract_esg_factors(self, opportunity: LongTermMetrics) -> List[str]:\n        \"\"\"Extract key ESG factors\"\"\"\n        factors = []\n        if opportunity.esg_score > 0.7:\n            factors.append(\"Strong ESG profile\")\n        elif opportunity.esg_score > 0.5:\n            factors.append(\"Average ESG profile\")\n        else:\n            factors.append(\"Below-average ESG profile\")\n            \n        return factors\n        \n    async def _determine_hedging_strategy(self, opportunity: LongTermMetrics) -> Optional[str]:\n        \"\"\"Determine appropriate hedging strategy for long-term position\"\"\"\n        try:\n            # Simple hedging strategy based on risk score\n            if opportunity.overall_score > 0.8:\n                # High conviction, high quality - minimal hedging\n                return \"Covered call\"  # Generate income while holding\n            elif opportunity.overall_score > 0.6:\n                # Moderate conviction - moderate hedging\n                return \"Collar\"  # Protect downside while maintaining upside\n            else:\n                # Lower conviction - more protection\n                return \"Protective put\"  # Downside protection\n                \n        except Exception as e:\n            logger.warning(f\"Error determining hedging strategy: {e}\")\n            return \"Covered call\"  # Default conservative strategy\n\n# Create global instance\nlong_term_core_agent = LongTermCoreAgent()\n\n# Convenience function for LangGraph integration\nasync def long_term_core_agent_node(state):\n    \"\"\"LangGraph node function for long-term core agent\"\"\"\n    try:\n        agent = LongTermCoreAgent()\n        symbols = state.get('symbols', [])\n        \n        if not symbols:\n            logger.warning(\"No symbols provided for long-term core analysis\")\n            return {\"long_term_signals\": []}\n            \n        # Generate long-term signals\n        signals = await agent.generate_long_term_signals(symbols)\n        \n        return {\n            \"long_term_signals\": signals,\n            \"analysis_timestamp\": datetime.now()\n        }\n    except Exception as e:\n        logger.error(f\"Error in long-term core agent node: {e}\")\n        return {\n            \"long_term_signals\": [],\n            \"error\": str(e)\n        }